<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>archivey.base_reader API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>archivey.base_reader</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="archivey.base_reader.create_member_filter"><code class="name flex">
<span>def <span class="ident">create_member_filter</span></span>(<span>members: Iterable[<a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a> | str] | None,<br>filter: Callable[[<a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a>], bool] | None) ‑> Callable[[<a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a>], bool] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_member_filter(
    members: Iterable[ArchiveMember | str] | None,
    filter: Callable[[ArchiveMember], bool] | None,
) -&gt; Callable[[ArchiveMember], bool] | None:
    if members is None:
        return filter

    members_to_write = {
        member.filename if isinstance(member, ArchiveMember) else member
        for member in members
    }

    return lambda member: member.filename in members_to_write and (
        filter is None or filter(member)
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="archivey.base_reader.ArchiveReader"><code class="flex name class">
<span>class <span class="ident">ArchiveReader</span></span>
<span>(</span><span>format: <a title="archivey.types.ArchiveFormat" href="types.html#archivey.types.ArchiveFormat">ArchiveFormat</a>,<br>archive_path: str | bytes | os.PathLike)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArchiveReader(abc.ABC):
    &#34;&#34;&#34;Abstract base class for archive streams.&#34;&#34;&#34;

    def __init__(
        self,
        format: ArchiveFormat,
        archive_path: str | bytes | os.PathLike,
    ):
        &#34;&#34;&#34;Initialize the archive reader.

        Args:
            format: The format of the archive
            archive_path: The path to the archive file
        &#34;&#34;&#34;
        self.format = format
        self.archive_path = (
            archive_path.decode(&#34;utf-8&#34;)
            if isinstance(archive_path, bytes)
            else str(archive_path)
        )
        self.config: ArchiveyConfig = get_default_config()
        self._member_map: dict[str, ArchiveMember] | None = None

    @abc.abstractmethod
    def close(self) -&gt; None:
        &#34;&#34;&#34;Close the archive stream and release any resources.&#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def get_members_if_available(self) -&gt; List[ArchiveMember] | None:
        &#34;&#34;&#34;Get a list of all members in the archive, or None if not available. May not be available for stream archives.&#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def iter_members_with_io(
        self,
        filter: Callable[[ArchiveMember], bool] | None = None,
        *,
        pwd: bytes | str | None = None,
    ) -&gt; Iterator[tuple[ArchiveMember, IO[bytes] | None]]:
        &#34;&#34;&#34;Iterate over all members in the archive.

        Args:
            filter: A filter function to apply to each member. If specified, only
            members for which the filter returns True will be yielded.
            The filter may be called for all members either before or during the
            iteration, so don&#39;t rely on any specific behavior.
            pwd: Password to use for decryption, if needed and different from the one
            used when opening the archive. May not be supported by all archive formats.

        Returns:
            A (ArchiveMember, IO[bytes]) iterator over the members. Each stream should
            be read before the next member is retrieved. The stream may be None if the
            member is not a file.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def get_archive_info(self) -&gt; ArchiveInfo:
        &#34;&#34;&#34;Get detailed information about the archive.

        Returns:
            ArchiveInfo: Detailed format information including compression method
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def has_random_access(self):
        &#34;&#34;&#34;Check if opening members is possible (i.e. not streaming-only access).&#34;&#34;&#34;
        pass

    def extractall(
        self,
        path: str | None = None,
        members: list[ArchiveMember | str] | None = None,
        pwd: bytes | str | None = None,
        filter: Callable[[ArchiveMember], bool] | None = None,
        preserve_links: bool = True,
    ) -&gt; dict[str, str]:
        written_paths: dict[str, str] = {}

        filter = create_member_filter(members, filter)

        if path is None:
            path = os.getcwd()

        for member, stream in self.iter_members_with_io(filter=filter, pwd=pwd):
            written_path = _write_member(path, member, preserve_links, stream)
            if written_path is not None:
                written_paths[member.filename] = written_path
            if stream is not None:
                stream.close()

        return written_paths

    # Context manager support
    def __enter__(self) -&gt; &#34;ArchiveReader&#34;:
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:
        self.close()

    # Methods only available for random access readers

    @abc.abstractmethod
    def get_members(self) -&gt; List[ArchiveMember]:
        &#34;&#34;&#34;Get a list of all members in the archive. May need to read the archive to get the members.&#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def open(
        self, member_or_filename: ArchiveMember | str, *, pwd: bytes | str | None = None
    ) -&gt; IO[bytes]:
        &#34;&#34;&#34;Open a member for reading.

        Args:
            member: The member to open
            pwd: Password to use for decryption, if needed and different from the one
            used when opening the archive.
        &#34;&#34;&#34;
        pass

    def _build_member_map(self) -&gt; dict[str, ArchiveMember]:
        if self._member_map is None:
            self._member_map = {
                member.filename: member for member in self.get_members()
            }
        return self._member_map

    def get_member(self, member_or_filename: ArchiveMember | str) -&gt; ArchiveMember:
        if isinstance(member_or_filename, ArchiveMember):
            return member_or_filename

        member_map = self._build_member_map()
        if member_or_filename not in member_map:
            raise ArchiveMemberNotFoundError(f&#34;Member not found: {member_or_filename}&#34;)
        return member_map[member_or_filename]

    def extract(
        self,
        member_or_filename: ArchiveMember | str,
        path: str | None = None,
        pwd: bytes | str | None = None,
        preserve_links: bool = True,
    ) -&gt; str | None:
        # Try using open(). Assume that, if it&#39;s possible to open a member,
        # get_member() is also available.
        if self.has_random_access():
            member = self.get_member(member_or_filename)
            stream = self.open(member, pwd=pwd)
            return _write_member(path or os.getcwd(), member, preserve_links, stream)

        # Fall back to extractall().
        logger.warning(
            &#34;extract() may be slow for streaming archives, use extractall instead if possible. ()&#34;
        )
        d = self.extractall(
            path=path,
            members=[member_or_filename],
            pwd=pwd,
            preserve_links=preserve_links,
        )
        return list(d.values())[0] if len(d) else None</code></pre>
</details>
<div class="desc"><p>Abstract base class for archive streams.</p>
<p>Initialize the archive reader.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>format</code></strong></dt>
<dd>The format of the archive</dd>
<dt><strong><code>archive_path</code></strong></dt>
<dd>The path to the archive file</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="archivey.base_reader.BaseArchiveReaderRandomAccess" href="#archivey.base_reader.BaseArchiveReaderRandomAccess">BaseArchiveReaderRandomAccess</a></li>
<li><a title="archivey.base_reader.StreamingOnlyArchiveReaderWrapper" href="#archivey.base_reader.StreamingOnlyArchiveReaderWrapper">StreamingOnlyArchiveReaderWrapper</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="archivey.base_reader.ArchiveReader.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def close(self) -&gt; None:
    &#34;&#34;&#34;Close the archive stream and release any resources.&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Close the archive stream and release any resources.</p></div>
</dd>
<dt id="archivey.base_reader.ArchiveReader.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self,<br>member_or_filename: <a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a> | str,<br>path: str | None = None,<br>pwd: str | bytes | None = None,<br>preserve_links: bool = True) ‑> str | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract(
    self,
    member_or_filename: ArchiveMember | str,
    path: str | None = None,
    pwd: bytes | str | None = None,
    preserve_links: bool = True,
) -&gt; str | None:
    # Try using open(). Assume that, if it&#39;s possible to open a member,
    # get_member() is also available.
    if self.has_random_access():
        member = self.get_member(member_or_filename)
        stream = self.open(member, pwd=pwd)
        return _write_member(path or os.getcwd(), member, preserve_links, stream)

    # Fall back to extractall().
    logger.warning(
        &#34;extract() may be slow for streaming archives, use extractall instead if possible. ()&#34;
    )
    d = self.extractall(
        path=path,
        members=[member_or_filename],
        pwd=pwd,
        preserve_links=preserve_links,
    )
    return list(d.values())[0] if len(d) else None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="archivey.base_reader.ArchiveReader.extractall"><code class="name flex">
<span>def <span class="ident">extractall</span></span>(<span>self,<br>path: str | None = None,<br>members: list[<a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a> | str] | None = None,<br>pwd: str | bytes | None = None,<br>filter: Callable[[<a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a>], bool] | None = None,<br>preserve_links: bool = True) ‑> dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extractall(
    self,
    path: str | None = None,
    members: list[ArchiveMember | str] | None = None,
    pwd: bytes | str | None = None,
    filter: Callable[[ArchiveMember], bool] | None = None,
    preserve_links: bool = True,
) -&gt; dict[str, str]:
    written_paths: dict[str, str] = {}

    filter = create_member_filter(members, filter)

    if path is None:
        path = os.getcwd()

    for member, stream in self.iter_members_with_io(filter=filter, pwd=pwd):
        written_path = _write_member(path, member, preserve_links, stream)
        if written_path is not None:
            written_paths[member.filename] = written_path
        if stream is not None:
            stream.close()

    return written_paths</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="archivey.base_reader.ArchiveReader.get_archive_info"><code class="name flex">
<span>def <span class="ident">get_archive_info</span></span>(<span>self) ‑> <a title="archivey.types.ArchiveInfo" href="types.html#archivey.types.ArchiveInfo">ArchiveInfo</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_archive_info(self) -&gt; ArchiveInfo:
    &#34;&#34;&#34;Get detailed information about the archive.

    Returns:
        ArchiveInfo: Detailed format information including compression method
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Get detailed information about the archive.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ArchiveInfo</code></dt>
<dd>Detailed format information including compression method</dd>
</dl></div>
</dd>
<dt id="archivey.base_reader.ArchiveReader.get_member"><code class="name flex">
<span>def <span class="ident">get_member</span></span>(<span>self,<br>member_or_filename: <a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a> | str) ‑> <a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_member(self, member_or_filename: ArchiveMember | str) -&gt; ArchiveMember:
    if isinstance(member_or_filename, ArchiveMember):
        return member_or_filename

    member_map = self._build_member_map()
    if member_or_filename not in member_map:
        raise ArchiveMemberNotFoundError(f&#34;Member not found: {member_or_filename}&#34;)
    return member_map[member_or_filename]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="archivey.base_reader.ArchiveReader.get_members"><code class="name flex">
<span>def <span class="ident">get_members</span></span>(<span>self) ‑> List[<a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_members(self) -&gt; List[ArchiveMember]:
    &#34;&#34;&#34;Get a list of all members in the archive. May need to read the archive to get the members.&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Get a list of all members in the archive. May need to read the archive to get the members.</p></div>
</dd>
<dt id="archivey.base_reader.ArchiveReader.get_members_if_available"><code class="name flex">
<span>def <span class="ident">get_members_if_available</span></span>(<span>self) ‑> List[<a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a>] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_members_if_available(self) -&gt; List[ArchiveMember] | None:
    &#34;&#34;&#34;Get a list of all members in the archive, or None if not available. May not be available for stream archives.&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Get a list of all members in the archive, or None if not available. May not be available for stream archives.</p></div>
</dd>
<dt id="archivey.base_reader.ArchiveReader.has_random_access"><code class="name flex">
<span>def <span class="ident">has_random_access</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def has_random_access(self):
    &#34;&#34;&#34;Check if opening members is possible (i.e. not streaming-only access).&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Check if opening members is possible (i.e. not streaming-only access).</p></div>
</dd>
<dt id="archivey.base_reader.ArchiveReader.iter_members_with_io"><code class="name flex">
<span>def <span class="ident">iter_members_with_io</span></span>(<span>self,<br>filter: Callable[[<a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a>], bool] | None = None,<br>*,<br>pwd: str | bytes | None = None) ‑> Iterator[tuple[<a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a>, IO[bytes] | None]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def iter_members_with_io(
    self,
    filter: Callable[[ArchiveMember], bool] | None = None,
    *,
    pwd: bytes | str | None = None,
) -&gt; Iterator[tuple[ArchiveMember, IO[bytes] | None]]:
    &#34;&#34;&#34;Iterate over all members in the archive.

    Args:
        filter: A filter function to apply to each member. If specified, only
        members for which the filter returns True will be yielded.
        The filter may be called for all members either before or during the
        iteration, so don&#39;t rely on any specific behavior.
        pwd: Password to use for decryption, if needed and different from the one
        used when opening the archive. May not be supported by all archive formats.

    Returns:
        A (ArchiveMember, IO[bytes]) iterator over the members. Each stream should
        be read before the next member is retrieved. The stream may be None if the
        member is not a file.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Iterate over all members in the archive.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filter</code></strong></dt>
<dd>A filter function to apply to each member. If specified, only</dd>
<dt>members for which the filter returns True will be yielded.</dt>
<dt>The filter may be called for all members either before or during the</dt>
<dt>iteration, so don't rely on any specific behavior.</dt>
<dt><strong><code>pwd</code></strong></dt>
<dd>Password to use for decryption, if needed and different from the one</dd>
</dl>
<p>used when opening the archive. May not be supported by all archive formats.</p>
<h2 id="returns">Returns</h2>
<p>A (ArchiveMember, IO[bytes]) iterator over the members. Each stream should
be read before the next member is retrieved. The stream may be None if the
member is not a file.</p></div>
</dd>
<dt id="archivey.base_reader.ArchiveReader.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self,<br>member_or_filename: <a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a> | str,<br>*,<br>pwd: str | bytes | None = None) ‑> IO[bytes]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def open(
    self, member_or_filename: ArchiveMember | str, *, pwd: bytes | str | None = None
) -&gt; IO[bytes]:
    &#34;&#34;&#34;Open a member for reading.

    Args:
        member: The member to open
        pwd: Password to use for decryption, if needed and different from the one
        used when opening the archive.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Open a member for reading.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>member</code></strong></dt>
<dd>The member to open</dd>
<dt><strong><code>pwd</code></strong></dt>
<dd>Password to use for decryption, if needed and different from the one</dd>
</dl>
<p>used when opening the archive.</p></div>
</dd>
</dl>
</dd>
<dt id="archivey.base_reader.BaseArchiveReaderRandomAccess"><code class="flex name class">
<span>class <span class="ident">BaseArchiveReaderRandomAccess</span></span>
<span>(</span><span>format: <a title="archivey.types.ArchiveFormat" href="types.html#archivey.types.ArchiveFormat">ArchiveFormat</a>,<br>archive_path: str | bytes | os.PathLike)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseArchiveReaderRandomAccess(ArchiveReader):
    &#34;&#34;&#34;Abstract base class for archive readers which support random member access.&#34;&#34;&#34;

    def get_members_if_available(self) -&gt; List[ArchiveMember] | None:
        return self.get_members()

    def has_random_access(self) -&gt; bool:
        return True

    def iter_members_with_io(
        self,
        filter: Callable[[ArchiveMember], bool] | None = None,
        *,
        pwd: bytes | str | None = None,
    ) -&gt; Iterator[tuple[ArchiveMember, IO[bytes] | None]]:
        &#34;&#34;&#34;Default implementation of iter_members for random access archives.&#34;&#34;&#34;
        for member in self.get_members():
            if filter is None or filter(member):
                try:
                    # TODO: some libraries support fast seeking for files with no
                    # compression, so we should use that if possible.
                    actual_open = functools.partial(self.open, pwd=pwd)
                    stream = LazyOpenIO(actual_open, member, seekable=False)
                    yield member, stream
                    stream.close()
                except (ArchiveError, OSError) as e:
                    logger.warning(
                        &#34;Error opening member %s&#34;, member.filename, exc_info=True
                    )
                    # The caller should only get the exception if it actually tries
                    # to read from the stream.
                    yield member, ErrorIOStream(e)

    def getinfo(self, name: str) -&gt; ArchiveMember:
        for member in self.get_members():
            if member.filename == name:
                return member
        raise ArchiveMemberNotFoundError(f&#34;Member not found: {name}&#34;)</code></pre>
</details>
<div class="desc"><p>Abstract base class for archive readers which support random member access.</p>
<p>Initialize the archive reader.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>format</code></strong></dt>
<dd>The format of the archive</dd>
<dt><strong><code>archive_path</code></strong></dt>
<dd>The path to the archive file</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="archivey.base_reader.ArchiveReader" href="#archivey.base_reader.ArchiveReader">ArchiveReader</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="archivey.folder_reader.FolderReader" href="folder_reader.html#archivey.folder_reader.FolderReader">FolderReader</a></li>
<li><a title="archivey.iso_reader.IsoReader" href="iso_reader.html#archivey.iso_reader.IsoReader">IsoReader</a></li>
<li><a title="archivey.rar_reader.BaseRarReader" href="rar_reader.html#archivey.rar_reader.BaseRarReader">BaseRarReader</a></li>
<li><a title="archivey.sevenzip_reader.SevenZipReader" href="sevenzip_reader.html#archivey.sevenzip_reader.SevenZipReader">SevenZipReader</a></li>
<li><a title="archivey.single_file_reader.SingleFileReader" href="single_file_reader.html#archivey.single_file_reader.SingleFileReader">SingleFileReader</a></li>
<li><a title="archivey.tar_reader.TarReader" href="tar_reader.html#archivey.tar_reader.TarReader">TarReader</a></li>
<li><a title="archivey.zip_reader.ZipReader" href="zip_reader.html#archivey.zip_reader.ZipReader">ZipReader</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="archivey.base_reader.BaseArchiveReaderRandomAccess.getinfo"><code class="name flex">
<span>def <span class="ident">getinfo</span></span>(<span>self, name: str) ‑> <a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getinfo(self, name: str) -&gt; ArchiveMember:
    for member in self.get_members():
        if member.filename == name:
            return member
    raise ArchiveMemberNotFoundError(f&#34;Member not found: {name}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="archivey.base_reader.BaseArchiveReaderRandomAccess.iter_members_with_io"><code class="name flex">
<span>def <span class="ident">iter_members_with_io</span></span>(<span>self,<br>filter: Callable[[<a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a>], bool] | None = None,<br>*,<br>pwd: str | bytes | None = None) ‑> Iterator[tuple[<a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a>, IO[bytes] | None]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_members_with_io(
    self,
    filter: Callable[[ArchiveMember], bool] | None = None,
    *,
    pwd: bytes | str | None = None,
) -&gt; Iterator[tuple[ArchiveMember, IO[bytes] | None]]:
    &#34;&#34;&#34;Default implementation of iter_members for random access archives.&#34;&#34;&#34;
    for member in self.get_members():
        if filter is None or filter(member):
            try:
                # TODO: some libraries support fast seeking for files with no
                # compression, so we should use that if possible.
                actual_open = functools.partial(self.open, pwd=pwd)
                stream = LazyOpenIO(actual_open, member, seekable=False)
                yield member, stream
                stream.close()
            except (ArchiveError, OSError) as e:
                logger.warning(
                    &#34;Error opening member %s&#34;, member.filename, exc_info=True
                )
                # The caller should only get the exception if it actually tries
                # to read from the stream.
                yield member, ErrorIOStream(e)</code></pre>
</details>
<div class="desc"><p>Default implementation of iter_members for random access archives.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="archivey.base_reader.ArchiveReader" href="#archivey.base_reader.ArchiveReader">ArchiveReader</a></b></code>:
<ul class="hlist">
<li><code><a title="archivey.base_reader.ArchiveReader.close" href="#archivey.base_reader.ArchiveReader.close">close</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.get_archive_info" href="#archivey.base_reader.ArchiveReader.get_archive_info">get_archive_info</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.get_members" href="#archivey.base_reader.ArchiveReader.get_members">get_members</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.get_members_if_available" href="#archivey.base_reader.ArchiveReader.get_members_if_available">get_members_if_available</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.has_random_access" href="#archivey.base_reader.ArchiveReader.has_random_access">has_random_access</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.open" href="#archivey.base_reader.ArchiveReader.open">open</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="archivey.base_reader.StreamingOnlyArchiveReaderWrapper"><code class="flex name class">
<span>class <span class="ident">StreamingOnlyArchiveReaderWrapper</span></span>
<span>(</span><span>reader: <a title="archivey.base_reader.ArchiveReader" href="#archivey.base_reader.ArchiveReader">ArchiveReader</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StreamingOnlyArchiveReaderWrapper(ArchiveReader):
    &#34;&#34;&#34;Wrapper for archive readers that only support streaming access.&#34;&#34;&#34;

    def __init__(self, reader: ArchiveReader):
        self.reader = reader

    def close(self) -&gt; None:
        self.reader.close()

    def get_members_if_available(self) -&gt; List[ArchiveMember] | None:
        return self.reader.get_members_if_available()

    def iter_members_with_io(
        self,
        filter: Callable[[ArchiveMember], bool] | None = None,
        *,
        pwd: bytes | str | None = None,
    ) -&gt; Iterator[tuple[ArchiveMember, IO[bytes] | None]]:
        return self.reader.iter_members_with_io(filter, pwd=pwd)

    def get_archive_info(self) -&gt; ArchiveInfo:
        return self.reader.get_archive_info()

    def has_random_access(self) -&gt; bool:
        return False

    def extractall(
        self,
        path: str | None = None,
        members: list[ArchiveMember | str] | None = None,
        pwd: bytes | str | None = None,
        filter: Callable[[ArchiveMember], bool] | None = None,
        preserve_links: bool = True,
    ) -&gt; dict[str, str]:
        return self.reader.extractall(path, members, pwd, filter, preserve_links)

    # Unsupported methods for streaming-only readers

    def get_members(self) -&gt; List[ArchiveMember]:
        raise ValueError(
            &#34;Streaming-only archive reader does not support get_members().&#34;
        )

    def open(
        self, member: ArchiveMember, *, pwd: bytes | str | None = None
    ) -&gt; IO[bytes]:
        raise ValueError(&#34;Streaming-only archive reader does not support open().&#34;)

    def extract(
        self,
        member_or_filename: ArchiveMember | str,
        path: str | None = None,
        pwd: bytes | str | None = None,
        preserve_links: bool = True,
    ) -&gt; str | None:
        raise ValueError(&#34;Streaming-only archive reader does not support extract().&#34;)</code></pre>
</details>
<div class="desc"><p>Wrapper for archive readers that only support streaming access.</p>
<p>Initialize the archive reader.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>format</code></strong></dt>
<dd>The format of the archive</dd>
<dt><strong><code>archive_path</code></strong></dt>
<dd>The path to the archive file</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="archivey.base_reader.ArchiveReader" href="#archivey.base_reader.ArchiveReader">ArchiveReader</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="archivey.base_reader.StreamingOnlyArchiveReaderWrapper.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self,<br>member_or_filename: <a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a> | str,<br>path: str | None = None,<br>pwd: str | bytes | None = None,<br>preserve_links: bool = True) ‑> str | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract(
    self,
    member_or_filename: ArchiveMember | str,
    path: str | None = None,
    pwd: bytes | str | None = None,
    preserve_links: bool = True,
) -&gt; str | None:
    raise ValueError(&#34;Streaming-only archive reader does not support extract().&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="archivey.base_reader.StreamingOnlyArchiveReaderWrapper.extractall"><code class="name flex">
<span>def <span class="ident">extractall</span></span>(<span>self,<br>path: str | None = None,<br>members: list[<a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a> | str] | None = None,<br>pwd: str | bytes | None = None,<br>filter: Callable[[<a title="archivey.types.ArchiveMember" href="types.html#archivey.types.ArchiveMember">ArchiveMember</a>], bool] | None = None,<br>preserve_links: bool = True) ‑> dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extractall(
    self,
    path: str | None = None,
    members: list[ArchiveMember | str] | None = None,
    pwd: bytes | str | None = None,
    filter: Callable[[ArchiveMember], bool] | None = None,
    preserve_links: bool = True,
) -&gt; dict[str, str]:
    return self.reader.extractall(path, members, pwd, filter, preserve_links)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="archivey.base_reader.ArchiveReader" href="#archivey.base_reader.ArchiveReader">ArchiveReader</a></b></code>:
<ul class="hlist">
<li><code><a title="archivey.base_reader.ArchiveReader.close" href="#archivey.base_reader.ArchiveReader.close">close</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.get_archive_info" href="#archivey.base_reader.ArchiveReader.get_archive_info">get_archive_info</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.get_members" href="#archivey.base_reader.ArchiveReader.get_members">get_members</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.get_members_if_available" href="#archivey.base_reader.ArchiveReader.get_members_if_available">get_members_if_available</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.has_random_access" href="#archivey.base_reader.ArchiveReader.has_random_access">has_random_access</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.iter_members_with_io" href="#archivey.base_reader.ArchiveReader.iter_members_with_io">iter_members_with_io</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.open" href="#archivey.base_reader.ArchiveReader.open">open</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="archivey" href="index.html">archivey</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="archivey.base_reader.create_member_filter" href="#archivey.base_reader.create_member_filter">create_member_filter</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="archivey.base_reader.ArchiveReader" href="#archivey.base_reader.ArchiveReader">ArchiveReader</a></code></h4>
<ul class="">
<li><code><a title="archivey.base_reader.ArchiveReader.close" href="#archivey.base_reader.ArchiveReader.close">close</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.extract" href="#archivey.base_reader.ArchiveReader.extract">extract</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.extractall" href="#archivey.base_reader.ArchiveReader.extractall">extractall</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.get_archive_info" href="#archivey.base_reader.ArchiveReader.get_archive_info">get_archive_info</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.get_member" href="#archivey.base_reader.ArchiveReader.get_member">get_member</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.get_members" href="#archivey.base_reader.ArchiveReader.get_members">get_members</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.get_members_if_available" href="#archivey.base_reader.ArchiveReader.get_members_if_available">get_members_if_available</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.has_random_access" href="#archivey.base_reader.ArchiveReader.has_random_access">has_random_access</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.iter_members_with_io" href="#archivey.base_reader.ArchiveReader.iter_members_with_io">iter_members_with_io</a></code></li>
<li><code><a title="archivey.base_reader.ArchiveReader.open" href="#archivey.base_reader.ArchiveReader.open">open</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="archivey.base_reader.BaseArchiveReaderRandomAccess" href="#archivey.base_reader.BaseArchiveReaderRandomAccess">BaseArchiveReaderRandomAccess</a></code></h4>
<ul class="">
<li><code><a title="archivey.base_reader.BaseArchiveReaderRandomAccess.getinfo" href="#archivey.base_reader.BaseArchiveReaderRandomAccess.getinfo">getinfo</a></code></li>
<li><code><a title="archivey.base_reader.BaseArchiveReaderRandomAccess.iter_members_with_io" href="#archivey.base_reader.BaseArchiveReaderRandomAccess.iter_members_with_io">iter_members_with_io</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="archivey.base_reader.StreamingOnlyArchiveReaderWrapper" href="#archivey.base_reader.StreamingOnlyArchiveReaderWrapper">StreamingOnlyArchiveReaderWrapper</a></code></h4>
<ul class="">
<li><code><a title="archivey.base_reader.StreamingOnlyArchiveReaderWrapper.extract" href="#archivey.base_reader.StreamingOnlyArchiveReaderWrapper.extract">extract</a></code></li>
<li><code><a title="archivey.base_reader.StreamingOnlyArchiveReaderWrapper.extractall" href="#archivey.base_reader.StreamingOnlyArchiveReaderWrapper.extractall">extractall</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
